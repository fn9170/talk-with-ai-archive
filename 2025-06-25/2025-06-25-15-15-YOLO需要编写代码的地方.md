# YOLO é¡¹ç›®ç¼–ç æŒ‡å— - å“ªäº›åœ°æ–¹éœ€è¦å†™ä»£ç ï¼Ÿ

## ğŸ¯ æ ¸å¿ƒç†è§£

ä½ è¯´å¾—å¯¹ï¼YOLOçš„åŸºæœ¬æµç¨‹ç¡®å®å¾ˆç®€å•ï¼š
1. **å‡†å¤‡æ•°æ®é›†** - å›¾ç‰‡ + æ ‡æ³¨
2. **è®­ç»ƒæ¨¡å‹** - å‡ è¡Œä»£ç å°±æå®š
3. **ä½¿ç”¨æ¨¡å‹** - åŠ è½½æ¨¡å‹è¿›è¡Œæ£€æµ‹

ä½†åœ¨**å®é™…é¡¹ç›®**ä¸­ï¼Œéœ€è¦ç¼–å†™ä»£ç çš„åœ°æ–¹æ¯”æƒ³è±¡ä¸­å¤šã€‚è®©æˆ‘è¯¦ç»†ç»™ä½ æ¢³ç†ï¼

---

## ğŸ“Š è®­ç»ƒé˜¶æ®µéœ€è¦ç¼–å†™çš„ä»£ç 

### 1. æ•°æ®é›†éªŒè¯ä»£ç ï¼ˆå¿…é¡»å†™ï¼‰
è™½ç„¶æ•°æ®é›†å‡†å¤‡ä¸»è¦æ˜¯æ‰‹å·¥æ ‡æ³¨ï¼Œä½†éªŒè¯ä»£ç å¿…é¡»è‡ªå·±å†™ï¼š

```python
# validate_dataset.py - æ•°æ®é›†éªŒè¯è„šæœ¬
import os
import glob

def check_dataset_integrity(dataset_path):
    """æ£€æŸ¥æ•°æ®é›†å®Œæ•´æ€§"""
    print("ğŸ” å¼€å§‹æ£€æŸ¥æ•°æ®é›†...")
    
    # 1. æ£€æŸ¥ç›®å½•ç»“æ„
    required_dirs = ['images/train', 'images/val', 'labels/train', 'labels/val']
    for dir_name in required_dirs:
        dir_path = os.path.join(dataset_path, dir_name)
        if not os.path.exists(dir_path):
            print(f"âŒ ç¼ºå°‘ç›®å½•: {dir_name}")
            return False
        print(f"âœ… ç›®å½•å­˜åœ¨: {dir_name}")
    
    # 2. æ£€æŸ¥æ–‡ä»¶å¯¹åº”å…³ç³»
    for split in ['train', 'val']:
        img_dir = os.path.join(dataset_path, 'images', split)
        label_dir = os.path.join(dataset_path, 'labels', split)
        
        img_files = set(os.path.splitext(f)[0] for f in os.listdir(img_dir))
        label_files = set(os.path.splitext(f)[0] for f in os.listdir(label_dir))
        
        missing_labels = img_files - label_files
        if missing_labels:
            print(f"âŒ {split}é›†ç¼ºå°‘æ ‡ç­¾: {missing_labels}")
        else:
            print(f"âœ… {split}é›†æ–‡ä»¶å¯¹åº”å…³ç³»æ­£ç¡®")
    
    return True

def validate_label_format(dataset_path):
    """éªŒè¯æ ‡ç­¾æ ¼å¼"""
    print("\nğŸ” æ£€æŸ¥æ ‡ç­¾æ ¼å¼...")
    
    for split in ['train', 'val']:
        label_dir = os.path.join(dataset_path, 'labels', split)
        label_files = glob.glob(os.path.join(label_dir, '*.txt'))
        
        error_count = 0
        for label_file in label_files:
            with open(label_file, 'r') as f:
                lines = f.readlines()
            
            for line_num, line in enumerate(lines, 1):
                line = line.strip()
                if not line:
                    continue
                
                parts = line.split()
                if len(parts) != 5:
                    print(f"âŒ {label_file}:{line_num} æ ¼å¼é”™è¯¯")
                    error_count += 1
                    continue
                
                try:
                    class_id, x, y, w, h = map(float, parts)
                    if not (0 <= x <= 1 and 0 <= y <= 1 and 0 <= w <= 1 and 0 <= h <= 1):
                        print(f"âŒ {label_file}:{line_num} åæ ‡è¶…å‡ºèŒƒå›´")
                        error_count += 1
                except ValueError:
                    print(f"âŒ {label_file}:{line_num} åŒ…å«éæ•°å­—")
                    error_count += 1
        
        if error_count == 0:
            print(f"âœ… {split}é›†æ ‡ç­¾æ ¼å¼æ­£ç¡®")
    
    return error_count == 0

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    dataset_path = "./my_dataset"
    if check_dataset_integrity(dataset_path) and validate_label_format(dataset_path):
        print("\nğŸ‰ æ•°æ®é›†éªŒè¯é€šè¿‡ï¼Œå¯ä»¥å¼€å§‹è®­ç»ƒï¼")
    else:
        print("\nğŸ’¥ æ•°æ®é›†æœ‰é—®é¢˜ï¼Œè¯·ä¿®å¤åå†è®­ç»ƒ")
```

### 2. è®­ç»ƒé…ç½®ä»£ç ï¼ˆæ¨èå†™ï¼‰
```python
# train_model.py - è®­ç»ƒè„šæœ¬
from ultralytics import YOLO
from datetime import datetime
import os

def train_yolo_model():
    """è®­ç»ƒYOLOæ¨¡å‹"""
    print("ğŸš€ å¼€å§‹è®­ç»ƒYOLOæ¨¡å‹...")
    
    # è®­ç»ƒé…ç½®
    config = {
        'data': 'data.yaml',        # æ•°æ®é…ç½®æ–‡ä»¶
        'model': 'yolov8n.pt',      # é¢„è®­ç»ƒæ¨¡å‹
        'epochs': 100,              # è®­ç»ƒè½®æ•°
        'batch': 16,                # æ‰¹æ¬¡å¤§å°
        'imgsz': 640,              # å›¾ç‰‡å¤§å°
        'device': 'auto',           # è‡ªåŠ¨é€‰æ‹©è®¾å¤‡
        'project': 'runs/train',    # ä¿å­˜ç›®å½•
        'name': f'exp_{datetime.now().strftime("%Y%m%d_%H%M%S")}',
        'save_period': 10,          # æ¯10è½®ä¿å­˜ä¸€æ¬¡
    }
    
    # åŠ è½½æ¨¡å‹
    model = YOLO(config['model'])
    
    # å¼€å§‹è®­ç»ƒ
    results = model.train(**config)
    
    print(f"âœ… è®­ç»ƒå®Œæˆï¼æ¨¡å‹ä¿å­˜åœ¨: {results.save_dir}")
    
    # è¯„ä¼°æœ€ä½³æ¨¡å‹
    best_model = os.path.join(results.save_dir, 'weights', 'best.pt')
    metrics = model.val(data=config['data'])
    
    print(f"ğŸ“Š æ¨¡å‹æ€§èƒ½:")
    print(f"mAP50: {metrics.box.map50:.3f}")
    print(f"mAP50-95: {metrics.box.map:.3f}")
    
    return best_model

if __name__ == "__main__":
    best_model_path = train_yolo_model()
    print(f"ğŸ‰ æœ€ä½³æ¨¡å‹: {best_model_path}")
```

---

## ğŸ”§ åº”ç”¨é˜¶æ®µéœ€è¦ç¼–å†™çš„ä»£ç 

### 1. æ¨¡å‹æ¨ç†å°è£…ï¼ˆå¿…é¡»å†™ï¼‰
```python
# detector.py - æ£€æµ‹å™¨å°è£…
from ultralytics import YOLO
import cv2
import numpy as np
from typing import List, Dict

class YOLODetector:
    def __init__(self, model_path: str, conf_threshold: float = 0.5):
        """åˆå§‹åŒ–æ£€æµ‹å™¨"""
        self.model = YOLO(model_path)
        self.conf_threshold = conf_threshold
        self.class_names = self.model.names
        
    def detect_image(self, image_path: str) -> List[Dict]:
        """æ£€æµ‹å•å¼ å›¾ç‰‡"""
        results = self.model(image_path, conf=self.conf_threshold)
        return self._parse_results(results[0])
    
    def detect_frame(self, frame: np.ndarray) -> List[Dict]:
        """æ£€æµ‹è§†é¢‘å¸§"""
        results = self.model(frame, conf=self.conf_threshold)
        return self._parse_results(results[0])
    
    def _parse_results(self, result) -> List[Dict]:
        """è§£ææ£€æµ‹ç»“æœä¸ºæ ‡å‡†æ ¼å¼"""
        detections = []
        
        if result.boxes is not None:
            for box in result.boxes:
                detection = {
                    'class_id': int(box.cls[0].item()),
                    'class_name': self.class_names[int(box.cls[0].item())],
                    'confidence': float(box.conf[0].item()),
                    'bbox': {
                        'x1': float(box.xyxy[0][0].item()),
                        'y1': float(box.xyxy[0][1].item()),
                        'x2': float(box.xyxy[0][2].item()),
                        'y2': float(box.xyxy[0][3].item())
                    }
                }
                detections.append(detection)
        
        return detections
    
    def draw_detections(self, image: np.ndarray, detections: List[Dict]) -> np.ndarray:
        """åœ¨å›¾ç‰‡ä¸Šç»˜åˆ¶æ£€æµ‹ç»“æœ"""
        for detection in detections:
            bbox = detection['bbox']
            x1, y1, x2, y2 = int(bbox['x1']), int(bbox['y1']), int(bbox['x2']), int(bbox['y2'])
            
            # ç»˜åˆ¶è¾¹ç•Œæ¡†
            cv2.rectangle(image, (x1, y1), (x2, y2), (0, 255, 0), 2)
            
            # ç»˜åˆ¶æ ‡ç­¾
            label = f"{detection['class_name']}: {detection['confidence']:.2f}"
            cv2.putText(image, label, (x1, y1-10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)
        
        return image

# ä½¿ç”¨ç¤ºä¾‹
def main():
    detector = YOLODetector('best.pt', conf_threshold=0.5)
    
    # æ£€æµ‹å›¾ç‰‡
    detections = detector.detect_image('test.jpg')
    print(f"æ£€æµ‹åˆ° {len(detections)} ä¸ªç‰©ä½“")
    
    for i, det in enumerate(detections):
        print(f"ç‰©ä½“ {i+1}: {det['class_name']} ({det['confidence']:.2f})")

if __name__ == "__main__":
    main()
```

### 2. å®æ—¶æ£€æµ‹ä»£ç ï¼ˆå¸¸ç”¨åŠŸèƒ½ï¼‰
```python
# realtime_detection.py - å®æ—¶æ£€æµ‹
import cv2
import time
from detector import YOLODetector
import threading
import queue

class RealtimeDetector:
    def __init__(self, model_path: str, source: int = 0):
        self.detector = YOLODetector(model_path)
        self.cap = cv2.VideoCapture(source)
        self.frame_queue = queue.Queue(maxsize=2)
        self.result_queue = queue.Queue(maxsize=2)
        self.running = False
        
    def capture_frames(self):
        """æ•è·è§†é¢‘å¸§"""
        while self.running:
            ret, frame = self.cap.read()
            if ret:
                if not self.frame_queue.full():
                    self.frame_queue.put(frame)
    
    def process_frames(self):
        """å¤„ç†æ£€æµ‹"""
        while self.running:
            if not self.frame_queue.empty():
                frame = self.frame_queue.get()
                detections = self.detector.detect_frame(frame)
                
                # ç»˜åˆ¶æ£€æµ‹ç»“æœ
                result_frame = self.detector.draw_detections(frame.copy(), detections)
                
                # æ·»åŠ ä¿¡æ¯
                info_text = f"Objects: {len(detections)}"
                cv2.putText(result_frame, info_text, (10, 30), 
                           cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)
                
                if not self.result_queue.full():
                    self.result_queue.put((result_frame, detections))
    
    def start(self):
        """å¼€å§‹å®æ—¶æ£€æµ‹"""
        self.running = True
        
        # å¯åŠ¨çº¿ç¨‹
        capture_thread = threading.Thread(target=self.capture_frames)
        process_thread = threading.Thread(target=self.process_frames)
        
        capture_thread.start()
        process_thread.start()
        
        print("ğŸ¥ å®æ—¶æ£€æµ‹å·²å¯åŠ¨ï¼ŒæŒ‰ 'q' é€€å‡º")
        
        # æ˜¾ç¤ºç»“æœ
        while self.running:
            if not self.result_queue.empty():
                result_frame, detections = self.result_queue.get()
                
                cv2.imshow('Real-time Detection', result_frame)
                
                # æ‰“å°æ£€æµ‹ç»“æœ
                if detections:
                    print(f"æ£€æµ‹åˆ°: {[d['class_name'] for d in detections]}")
                
                if cv2.waitKey(1) & 0xFF == ord('q'):
                    break
        
        self.stop()
    
    def stop(self):
        """åœæ­¢æ£€æµ‹"""
        self.running = False
        self.cap.release()
        cv2.destroyAllWindows()

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    detector = RealtimeDetector('best.pt')
    detector.start()
```

### 3. Webåº”ç”¨ä»£ç ï¼ˆå®é™…é¡¹ç›®å¸¸éœ€è¦ï¼‰
```python
# app.py - Flask Webåº”ç”¨
from flask import Flask, request, jsonify, render_template_string
from werkzeug.utils import secure_filename
import os
import uuid
from detector import YOLODetector
import base64
import cv2
import numpy as np

app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = 'uploads'
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB

# åˆå§‹åŒ–æ£€æµ‹å™¨
detector = YOLODetector('best.pt')

# ç®€å•çš„HTMLæ¨¡æ¿
HTML_TEMPLATE = '''
<!DOCTYPE html>
<html>
<head>
    <title>YOLO æ£€æµ‹ç³»ç»Ÿ</title>
    <style>
        body { font-family: Arial; max-width: 800px; margin: 0 auto; padding: 20px; }
        .upload-area { border: 2px dashed #ccc; padding: 40px; text-align: center; }
        .result { margin-top: 20px; }
        .detection-item { background: #f5f5f5; padding: 10px; margin: 5px 0; }
    </style>
</head>
<body>
    <h1>ğŸ¯ YOLO ç›®æ ‡æ£€æµ‹ç³»ç»Ÿ</h1>
    
    <div class="upload-area">
        <input type="file" id="imageInput" accept="image/*">
        <br><br>
        <button onclick="detectObjects()">ğŸ” å¼€å§‹æ£€æµ‹</button>
    </div>
    
    <div id="result" class="result"></div>

    <script>
        async function detectObjects() {
            const fileInput = document.getElementById('imageInput');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('è¯·é€‰æ‹©å›¾ç‰‡');
                return;
            }
            
            const formData = new FormData();
            formData.append('image', file);
            
            document.getElementById('result').innerHTML = 'ğŸ”„ æ£€æµ‹ä¸­...';
            
            try {
                const response = await fetch('/api/detect', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (result.success) {
                    displayResults(result);
                } else {
                    alert('æ£€æµ‹å¤±è´¥ï¼š' + result.error);
                }
            } catch (error) {
                alert('è¯·æ±‚å¤±è´¥ï¼š' + error);
            }
        }
        
        function displayResults(result) {
            let html = `
                <h3>âœ… æ£€æµ‹ç»“æœï¼ˆå…± ${result.total_objects} ä¸ªç‰©ä½“ï¼‰</h3>
                <img src="data:image/jpeg;base64,${result.result_image}" style="max-width: 100%;">
                <h4>ğŸ“‹ è¯¦ç»†ä¿¡æ¯ï¼š</h4>
            `;
            
            result.detections.forEach((detection, index) => {
                html += `
                    <div class="detection-item">
                        <strong>ç‰©ä½“ ${index + 1}:</strong> ${detection.class_name} 
                        (ç½®ä¿¡åº¦: ${(detection.confidence * 100).toFixed(1)}%)
                    </div>
                `;
            });
            
            document.getElementById('result').innerHTML = html;
        }
    </script>
</body>
</html>
'''

@app.route('/')
def index():
    return render_template_string(HTML_TEMPLATE)

@app.route('/api/detect', methods=['POST'])
def detect_api():
    """æ£€æµ‹APIæ¥å£"""
    try:
        if 'image' not in request.files:
            return jsonify({'error': 'æ²¡æœ‰ä¸Šä¼ å›¾ç‰‡'}), 400
        
        file = request.files['image']
        if file.filename == '':
            return jsonify({'error': 'æ²¡æœ‰é€‰æ‹©æ–‡ä»¶'}), 400
        
        # ä¿å­˜ä¸Šä¼ çš„æ–‡ä»¶
        filename = secure_filename(file.filename)
        unique_filename = f"{uuid.uuid4()}_{filename}"
        filepath = os.path.join(app.config['UPLOAD_FOLDER'], unique_filename)
        file.save(filepath)
        
        # è¿›è¡Œæ£€æµ‹
        detections = detector.detect_image(filepath)
        
        # ç»˜åˆ¶ç»“æœå›¾ç‰‡
        image = cv2.imread(filepath)
        result_image = detector.draw_detections(image, detections)
        
        # è½¬æ¢ä¸ºbase64
        _, buffer = cv2.imencode('.jpg', result_image)
        image_base64 = base64.b64encode(buffer).decode()
        
        # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        os.remove(filepath)
        
        return jsonify({
            'success': True,
            'detections': detections,
            'result_image': image_base64,
            'total_objects': len(detections)
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

if __name__ == '__main__':
    os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
    print("ğŸŒ å¯åŠ¨WebæœåŠ¡å™¨...")
    print("è®¿é—®: http://localhost:5000")
    app.run(debug=True, host='0.0.0.0', port=5000)
```

### 4. æ‰¹é‡å¤„ç†ä»£ç ï¼ˆå®ç”¨å·¥å…·ï¼‰
```python
# batch_processor.py - æ‰¹é‡å¤„ç†
import os
import json
import time
from detector import YOLODetector
from concurrent.futures import ThreadPoolExecutor
import pandas as pd

class BatchProcessor:
    def __init__(self, model_path: str, max_workers: int = 4):
        self.detector = YOLODetector(model_path)
        self.max_workers = max_workers
    
    def process_single_image(self, image_path: str) -> dict:
        """å¤„ç†å•å¼ å›¾ç‰‡"""
        try:
            start_time = time.time()
            detections = self.detector.detect_image(image_path)
            processing_time = time.time() - start_time
            
            return {
                'image_path': image_path,
                'success': True,
                'detections': detections,
                'processing_time': processing_time,
                'total_objects': len(detections)
            }
        except Exception as e:
            return {
                'image_path': image_path,
                'success': False,
                'error': str(e)
            }
    
    def process_folder(self, input_folder: str, output_file: str = None):
        """æ‰¹é‡å¤„ç†æ–‡ä»¶å¤¹ä¸­çš„å›¾ç‰‡"""
        # è·å–æ‰€æœ‰å›¾ç‰‡æ–‡ä»¶
        image_extensions = ['.jpg', '.jpeg', '.png', '.bmp']
        image_paths = []
        
        for ext in image_extensions:
            image_paths.extend([
                os.path.join(input_folder, f) 
                for f in os.listdir(input_folder) 
                if f.lower().endswith(ext)
            ])
        
        print(f"ğŸ“ æ‰¾åˆ° {len(image_paths)} å¼ å›¾ç‰‡")
        
        # å¹¶è¡Œå¤„ç†
        results = []
        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            futures = [executor.submit(self.process_single_image, path) for path in image_paths]
            
            for i, future in enumerate(futures):
                result = future.result()
                results.append(result)
                
                # æ˜¾ç¤ºè¿›åº¦
                if result['success']:
                    print(f"âœ… [{i+1}/{len(image_paths)}] {os.path.basename(result['image_path'])}: {result['total_objects']} ä¸ªç‰©ä½“")
                else:
                    print(f"âŒ [{i+1}/{len(image_paths)}] {os.path.basename(result['image_path'])}: {result['error']}")
        
        # ç”Ÿæˆç»Ÿè®¡æŠ¥å‘Š
        self.generate_report(results)
        
        # ä¿å­˜ç»“æœ
        if output_file:
            self.save_results(results, output_file)
        
        return results
    
    def generate_report(self, results: list):
        """ç”Ÿæˆç»Ÿè®¡æŠ¥å‘Š"""
        successful = [r for r in results if r['success']]
        failed = [r for r in results if not r['success']]
        
        print(f"\nğŸ“Š å¤„ç†æŠ¥å‘Š:")
        print(f"æ€»å›¾ç‰‡æ•°: {len(results)}")
        print(f"æˆåŠŸå¤„ç†: {len(successful)} ({len(successful)/len(results)*100:.1f}%)")
        print(f"å¤„ç†å¤±è´¥: {len(failed)} ({len(failed)/len(results)*100:.1f}%)")
        
        if successful:
            total_objects = sum(r['total_objects'] for r in successful)
            avg_processing_time = sum(r['processing_time'] for r in successful) / len(successful)
            
            print(f"æ€»æ£€æµ‹ç‰©ä½“: {total_objects}")
            print(f"å¹³å‡å¤„ç†æ—¶é—´: {avg_processing_time:.2f}ç§’/å¼ ")
            
            # ç±»åˆ«ç»Ÿè®¡
            class_counts = {}
            for result in successful:
                for detection in result['detections']:
                    class_name = detection['class_name']
                    class_counts[class_name] = class_counts.get(class_name, 0) + 1
            
            print(f"\nğŸ·ï¸ æ£€æµ‹ç±»åˆ«åˆ†å¸ƒ:")
            for class_name, count in sorted(class_counts.items(), key=lambda x: x[1], reverse=True):
                print(f"  {class_name}: {count} æ¬¡")
    
    def save_results(self, results: list, output_file: str):
        """ä¿å­˜ç»“æœåˆ°æ–‡ä»¶"""
        if output_file.endswith('.json'):
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(results, f, indent=2, ensure_ascii=False)
        
        elif output_file.endswith('.csv'):
            # å±•å¼€æ£€æµ‹ç»“æœä¸ºCSVæ ¼å¼
            rows = []
            for result in results:
                if result['success']:
                    for detection in result['detections']:
                        rows.append({
                            'image_path': result['image_path'],
                            'class_name': detection['class_name'],
                            'confidence': detection['confidence'],
                            'x1': detection['bbox']['x1'],
                            'y1': detection['bbox']['y1'],
                            'x2': detection['bbox']['x2'],
                            'y2': detection['bbox']['y2']
                        })
            
            df = pd.DataFrame(rows)
            df.to_csv(output_file, index=False)
        
        print(f"ğŸ’¾ ç»“æœå·²ä¿å­˜åˆ°: {output_file}")

# ä½¿ç”¨ç¤ºä¾‹
def main():
    processor = BatchProcessor('best.pt', max_workers=4)
    
    # æ‰¹é‡å¤„ç†å›¾ç‰‡
    results = processor.process_folder(
        input_folder='test_images',
        output_file='detection_results.json'
    )

if __name__ == "__main__":
    main()
```

---

## ğŸ“‹ æ€»ç»“ï¼šéœ€è¦ç¼–å†™ä»£ç çš„åœ°æ–¹

### ğŸ”´ **å¿…é¡»ç¼–å†™çš„ä»£ç ï¼ˆçº¦300-500è¡Œï¼‰**
1. **æ•°æ®é›†éªŒè¯** (~100è¡Œ) - ç¡®ä¿è®­ç»ƒæ•°æ®æ­£ç¡®
2. **æ¨¡å‹æ¨ç†å°è£…** (~150è¡Œ) - æ ‡å‡†åŒ–æ£€æµ‹æ¥å£
3. **åŸºæœ¬åº”ç”¨æ¥å£** (~200è¡Œ) - Web APIæˆ–å‘½ä»¤è¡Œå·¥å…·

### ğŸŸ¡ **å¼ºçƒˆæ¨èçš„ä»£ç ï¼ˆçº¦500-800è¡Œï¼‰**
1. **è®­ç»ƒé…ç½®ç®¡ç†** (~100è¡Œ) - å‚æ•°è°ƒä¼˜
2. **å®æ—¶æ£€æµ‹** (~200è¡Œ) - è§†é¢‘æµå¤„ç†
3. **æ‰¹é‡å¤„ç†** (~200è¡Œ) - å¤§é‡å›¾ç‰‡å¤„ç†
4. **Webåº”ç”¨** (~300è¡Œ) - ç”¨æˆ·ç•Œé¢

### ğŸŸ¢ **å¯é€‰ä½†æœ‰ç”¨çš„ä»£ç ï¼ˆçº¦300-500è¡Œï¼‰**
1. **æ•°æ®å¢å¼º** (~150è¡Œ) - æé«˜æ¨¡å‹æ•ˆæœ
2. **ç»“æœåˆ†æ** (~200è¡Œ) - ç»Ÿè®¡å’Œå¯è§†åŒ–
3. **æ€§èƒ½ç›‘æ§** (~150è¡Œ) - ç³»ç»Ÿç›‘æ§

### ğŸ“Š **å¼€å‘æ—¶é—´ä¼°ç®—**
```
åŸºç¡€ç‰ˆæœ¬ï¼ˆèƒ½ç”¨ï¼‰: 1-2å¤©
- æ•°æ®éªŒè¯ + æ¨ç†å°è£… + ç®€å•æ¥å£

å®Œæ•´ç‰ˆæœ¬ï¼ˆå¥½ç”¨ï¼‰: 1-2å‘¨  
- åŒ…å«æ‰€æœ‰æ¨èåŠŸèƒ½
- å®Œå–„çš„é”™è¯¯å¤„ç†
- ç”¨æˆ·å‹å¥½çš„ç•Œé¢

ç”Ÿäº§ç‰ˆæœ¬ï¼ˆç¨³å®šï¼‰: 2-4å‘¨
- æ€§èƒ½ä¼˜åŒ–
- å®Œæ•´æµ‹è¯•
- éƒ¨ç½²é…ç½®
```

### ğŸ¯ **å¼€å‘å»ºè®®**
1. **ä»ç®€å•å¼€å§‹** - å…ˆå®ç°åŸºæœ¬åŠŸèƒ½
2. **é€æ­¥å®Œå–„** - æ ¹æ®éœ€æ±‚æ·»åŠ åŠŸèƒ½
3. **æ³¨é‡å¤ç”¨** - å°è£…é€šç”¨ç»„ä»¶
4. **åšå¥½æµ‹è¯•** - ç¡®ä¿ä»£ç ç¨³å®š

**æ€»ç»“ï¼šè™½ç„¶YOLOæœ¬èº«åªéœ€å‡ è¡Œä»£ç ï¼Œä½†è¦åšæˆå®ç”¨çš„é¡¹ç›®ï¼Œè¿˜æ˜¯éœ€è¦ç¼–å†™ä¸å°‘ä»£ç çš„ï¼ä¸»è¦å·¥ä½œé‡åœ¨æ•°æ®å¤„ç†ã€åº”ç”¨å°è£…å’Œç”¨æˆ·ç•Œé¢ä¸Šã€‚** 

éœ€è¦æˆ‘å¸®ä½ å®ç°ä»»ä½•å…·ä½“çš„éƒ¨åˆ†å—ï¼Ÿ 