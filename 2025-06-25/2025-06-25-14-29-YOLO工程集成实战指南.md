# YOLO v8 å·¥ç¨‹é›†æˆå®æˆ˜æŒ‡å— - ä»æ£€æµ‹ç»“æœåˆ°å®é™…åº”ç”¨

## ğŸ¯ ä»æ£€æµ‹ç»“æœåˆ°å·¥ç¨‹åº”ç”¨

ä½ å·²ç»æˆåŠŸè·å¾—äº†æ£€æµ‹ç»“æœå›¾ç‰‡ï¼ˆæ˜¾ç¤º `person_0.73`ï¼‰ï¼Œç°åœ¨è®©æˆ‘ä»¬æŠŠè¿™ä¸ªåŠŸèƒ½é›†æˆåˆ°å®é™…å·¥ç¨‹ä¸­ï¼

## ğŸ“Š è·å–æ£€æµ‹æ•°æ®ï¼ˆä¸åªæ˜¯å›¾ç‰‡ï¼‰

### 1. æå–è¯¦ç»†æ£€æµ‹ä¿¡æ¯
```python
from ultralytics import YOLO
import cv2
import json

def get_detection_data(image_path):
    model = YOLO('yolov8n.pt')
    results = model(image_path)
    
    # æå–æ£€æµ‹ä¿¡æ¯
    detections = []
    for box in results[0].boxes:
        x1, y1, x2, y2 = box.xyxy[0].tolist()  # è¾¹ç•Œæ¡†åæ ‡
        confidence = box.conf[0].item()        # ç½®ä¿¡åº¦
        class_id = int(box.cls[0].item())      # ç±»åˆ«ID
        class_name = results[0].names[class_id] # ç±»åˆ«åç§°
        
        detection = {
            'class_name': class_name,
            'class_id': class_id,
            'confidence': confidence,
            'bbox': {
                'x1': int(x1), 'y1': int(y1),
                'x2': int(x2), 'y2': int(y2),
                'width': int(x2 - x1),
                'height': int(y2 - y1)
            }
        }
        detections.append(detection)
    
    return detections

# ä½¿ç”¨ç¤ºä¾‹
detections = get_detection_data('images.jpeg')
print(json.dumps(detections, indent=2, ensure_ascii=False))
```

**è¾“å‡ºç¤ºä¾‹ï¼š**
```json
[
  {
    "class_name": "person",
    "class_id": 0,
    "confidence": 0.73,
    "bbox": {
      "x1": 150,
      "y1": 50,
      "x2": 400,
      "y2": 600,
      "width": 250,
      "height": 550
    }
  }
]
```

---

## ğŸŒ Webåº”ç”¨é›†æˆ

### 1. Flask Webåº”ç”¨
```python
# app.py
from flask import Flask, request, jsonify, render_template
from ultralytics import YOLO
import cv2
import numpy as np
from PIL import Image
import io
import base64
import os

app = Flask(__name__)
model = YOLO('yolov8n.pt')

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/detect', methods=['POST'])
def detect_objects():
    try:
        # æ¥æ”¶å›¾ç‰‡
        file = request.files['image']
        image = Image.open(file.stream)
        
        # è¿›è¡Œæ£€æµ‹
        results = model(image)
        
        # æå–æ£€æµ‹ç»“æœ
        detections = []
        for box in results[0].boxes:
            x1, y1, x2, y2 = box.xyxy[0].tolist()
            confidence = box.conf[0].item()
            class_id = int(box.cls[0].item())
            class_name = results[0].names[class_id]
            
            detections.append({
                'class_name': class_name,
                'confidence': round(confidence, 3),
                'bbox': [int(x1), int(y1), int(x2), int(y2)]
            })
        
        # ç”Ÿæˆæ ‡æ³¨å›¾ç‰‡
        annotated_img = results[0].plot()
        
        # è½¬æ¢ä¸ºbase64
        _, buffer = cv2.imencode('.jpg', annotated_img)
        img_base64 = base64.b64encode(buffer).decode()
        
        return jsonify({
            'success': True,
            'detections': detections,
            'annotated_image': img_base64,
            'total_objects': len(detections)
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)
```

### 2. å‰ç«¯é¡µé¢
```html
<!-- templates/index.html -->
<!DOCTYPE html>
<html>
<head>
    <title>YOLO ç›®æ ‡æ£€æµ‹</title>
    <style>
        .container { max-width: 800px; margin: 0 auto; padding: 20px; }
        .upload-area { 
            border: 2px dashed #ccc; 
            padding: 40px; 
            text-align: center; 
            border-radius: 10px;
        }
        .result-area { margin-top: 20px; }
        .detection-item { 
            background: #f5f5f5; 
            padding: 10px; 
            margin: 5px 0; 
            border-radius: 5px; 
        }
        .btn { 
            background: #007bff; 
            color: white; 
            padding: 10px 20px; 
            border: none; 
            border-radius: 5px; 
            cursor: pointer; 
        }
        .btn:hover { background: #0056b3; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¯ YOLO ç›®æ ‡æ£€æµ‹ç³»ç»Ÿ</h1>
        
        <div class="upload-area">
            <input type="file" id="imageInput" accept="image/*">
            <br><br>
            <button class="btn" onclick="detectObjects()">ğŸ” å¼€å§‹æ£€æµ‹</button>
        </div>
        
        <div class="result-area" id="results"></div>
    </div>

    <script>
        async function detectObjects() {
            const fileInput = document.getElementById('imageInput');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('è¯·é€‰æ‹©å›¾ç‰‡');
                return;
            }
            
            // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            document.getElementById('results').innerHTML = '<p>ğŸ”„ æ£€æµ‹ä¸­ï¼Œè¯·ç¨å€™...</p>';
            
            const formData = new FormData();
            formData.append('image', file);
            
            try {
                const response = await fetch('/detect', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (result.success) {
                    displayResults(result);
                } else {
                    alert('æ£€æµ‹å¤±è´¥ï¼š' + result.error);
                }
            } catch (error) {
                alert('è¯·æ±‚å¤±è´¥ï¼š' + error);
            }
        }
        
        function displayResults(result) {
            const resultsDiv = document.getElementById('results');
            
            let html = `
                <h3>âœ… æ£€æµ‹ç»“æœï¼ˆå…±å‘ç° ${result.total_objects} ä¸ªç‰©ä½“ï¼‰</h3>
                <img src="data:image/jpeg;base64,${result.annotated_image}" 
                     style="max-width: 100%; border: 1px solid #ddd; border-radius: 5px;">
                <h4>ğŸ“‹ è¯¦ç»†ä¿¡æ¯ï¼š</h4>
            `;
            
            result.detections.forEach((detection, index) => {
                html += `
                    <div class="detection-item">
                        <strong>ğŸ¯ ç‰©ä½“ ${index + 1}:</strong> ${detection.class_name} 
                        <span style="color: green;">(ç½®ä¿¡åº¦: ${(detection.confidence * 100).toFixed(1)}%)</span>
                        <br>ğŸ“ ä½ç½®: [${detection.bbox.join(', ')}]
                    </div>
                `;
            });
            
            resultsDiv.innerHTML = html;
        }
    </script>
</body>
</html>
```

---

## ğŸ¥ å®æ—¶è§†é¢‘æ£€æµ‹é›†æˆ

### 1. æ‘„åƒå¤´å®æ—¶æ£€æµ‹ç±»
```python
import cv2
from ultralytics import YOLO
import threading
import queue
import time

class RealTimeDetector:
    def __init__(self, model_path='yolov8n.pt'):
        self.model = YOLO(model_path)
        self.cap = cv2.VideoCapture(0)
        self.frame_queue = queue.Queue(maxsize=2)
        self.result_queue = queue.Queue(maxsize=2)
        self.running = False
        self.detection_callback = None
        
    def set_detection_callback(self, callback):
        """è®¾ç½®æ£€æµ‹ç»“æœå›è°ƒå‡½æ•°"""
        self.detection_callback = callback
        
    def capture_frames(self):
        """æ•è·æ‘„åƒå¤´å¸§"""
        while self.running:
            ret, frame = self.cap.read()
            if ret:
                if not self.frame_queue.full():
                    self.frame_queue.put(frame)
                    
    def process_frames(self):
        """å¤„ç†æ£€æµ‹"""
        while self.running:
            if not self.frame_queue.empty():
                frame = self.frame_queue.get()
                results = self.model(frame)
                
                # è·å–æ£€æµ‹ä¿¡æ¯
                detections = []
                for box in results[0].boxes:
                    x1, y1, x2, y2 = box.xyxy[0].tolist()
                    confidence = box.conf[0].item()
                    class_name = results[0].names[int(box.cls[0].item())]
                    
                    detections.append({
                        'class_name': class_name,
                        'confidence': confidence,
                        'bbox': [int(x1), int(y1), int(x2), int(y2)]
                    })
                
                # ç»˜åˆ¶ç»“æœ
                annotated_frame = results[0].plot()
                
                # è°ƒç”¨å›è°ƒå‡½æ•°
                if self.detection_callback:
                    self.detection_callback(detections)
                
                if not self.result_queue.full():
                    self.result_queue.put((annotated_frame, detections))
                    
    def start(self):
        """å¼€å§‹å®æ—¶æ£€æµ‹"""
        self.running = True
        
        # å¯åŠ¨çº¿ç¨‹
        capture_thread = threading.Thread(target=self.capture_frames)
        process_thread = threading.Thread(target=self.process_frames)
        
        capture_thread.start()
        process_thread.start()
        
        return capture_thread, process_thread
        
    def get_frame(self):
        """è·å–å¤„ç†åçš„å¸§"""
        if not self.result_queue.empty():
            return self.result_queue.get()
        return None, None
        
    def stop(self):
        """åœæ­¢æ£€æµ‹"""
        self.running = False
        self.cap.release()

# ä½¿ç”¨ç¤ºä¾‹ï¼šå‘½ä»¤è¡Œç‰ˆæœ¬
def detection_callback(detections):
    """æ£€æµ‹ç»“æœå›è°ƒå‡½æ•°"""
    if detections:
        print(f"æ£€æµ‹åˆ° {len(detections)} ä¸ªç‰©ä½“:")
        for det in detections:
            print(f"  - {det['class_name']}: {det['confidence']:.3f}")

def run_realtime_detection():
    detector = RealTimeDetector()
    detector.set_detection_callback(detection_callback)
    detector.start()
    
    print("å®æ—¶æ£€æµ‹å·²å¯åŠ¨ï¼ŒæŒ‰ 'q' é€€å‡º")
    
    while detector.running:
        frame, detections = detector.get_frame()
        
        if frame is not None:
            # æ˜¾ç¤ºæ£€æµ‹æ•°é‡
            cv2.putText(frame, f'Objects: {len(detections) if detections else 0}', 
                       (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)
            
            cv2.imshow('Real-time Detection', frame)
        
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break
            
    detector.stop()
    cv2.destroyAllWindows()
```

---

## ğŸ’¾ æ•°æ®åº“é›†æˆ

### 1. æ£€æµ‹ç»“æœæ•°æ®åº“ç®¡ç†
```python
import sqlite3
import json
from datetime import datetime

class DetectionDatabase:
    def __init__(self, db_path='detections.db'):
        self.db_path = db_path
        self.init_database()
        
    def init_database(self):
        """åˆå§‹åŒ–æ•°æ®åº“"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS detections (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                image_path TEXT NOT NULL,
                detection_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                total_objects INTEGER,
                detections_json TEXT,
                confidence_avg REAL
            )
        ''')
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS detection_objects (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                detection_id INTEGER,
                class_name TEXT,
                confidence REAL,
                x1 INTEGER, y1 INTEGER, x2 INTEGER, y2 INTEGER,
                FOREIGN KEY (detection_id) REFERENCES detections (id)
            )
        ''')
        
        conn.commit()
        conn.close()
        
    def save_detection(self, image_path, detections):
        """ä¿å­˜æ£€æµ‹ç»“æœ"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # è®¡ç®—å¹³å‡ç½®ä¿¡åº¦
        avg_confidence = sum(d['confidence'] for d in detections) / len(detections) if detections else 0
        
        # æ’å…¥ä¸»è®°å½•
        cursor.execute('''
            INSERT INTO detections (image_path, total_objects, detections_json, confidence_avg)
            VALUES (?, ?, ?, ?)
        ''', (image_path, len(detections), json.dumps(detections), avg_confidence))
        
        detection_id = cursor.lastrowid
        
        # æ’å…¥è¯¦ç»†å¯¹è±¡è®°å½•
        for detection in detections:
            bbox = detection['bbox']
            cursor.execute('''
                INSERT INTO detection_objects 
                (detection_id, class_name, confidence, x1, y1, x2, y2)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            ''', (detection_id, detection['class_name'], detection['confidence'],
                  bbox['x1'], bbox['y1'], bbox['x2'], bbox['y2']))
        
        conn.commit()
        conn.close()
        
        return detection_id
        
    def get_detection_history(self, limit=10):
        """è·å–æ£€æµ‹å†å²"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT id, image_path, detection_time, total_objects, confidence_avg
            FROM detections 
            ORDER BY detection_time DESC 
            LIMIT ?
        ''', (limit,))
        
        results = cursor.fetchall()
        conn.close()
        
        return results
        
    def get_class_statistics(self):
        """è·å–ç±»åˆ«ç»Ÿè®¡"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT class_name, COUNT(*) as count, AVG(confidence) as avg_confidence
            FROM detection_objects
            GROUP BY class_name
            ORDER BY count DESC
        ''')
        
        results = cursor.fetchall()
        conn.close()
        
        return results

# é›†æˆä½¿ç”¨ç¤ºä¾‹
def detect_and_save(image_path):
    """æ£€æµ‹å¹¶ä¿å­˜åˆ°æ•°æ®åº“"""
    # æ‰§è¡Œæ£€æµ‹
    model = YOLO('yolov8n.pt')
    results = model(image_path)
    
    # æå–æ£€æµ‹ä¿¡æ¯
    detections = []
    for box in results[0].boxes:
        x1, y1, x2, y2 = box.xyxy[0].tolist()
        confidence = box.conf[0].item()
        class_id = int(box.cls[0].item())
        class_name = results[0].names[class_id]
        
        detections.append({
            'class_name': class_name,
            'confidence': confidence,
            'bbox': {'x1': int(x1), 'y1': int(y1), 'x2': int(x2), 'y2': int(y2)}
        })
    
    # ä¿å­˜åˆ°æ•°æ®åº“
    db = DetectionDatabase()
    detection_id = db.save_detection(image_path, detections)
    
    print(f"âœ… æ£€æµ‹å®Œæˆï¼Œä¿å­˜è®°å½•ID: {detection_id}")
    print(f"ğŸ¯ æ£€æµ‹åˆ° {len(detections)} ä¸ªç‰©ä½“")
    
    return detections, detection_id
```

---

## ğŸ“Š APIæ¥å£è®¾è®¡

### 1. RESTful API
```python
from flask import Flask, request, jsonify
from flask_cors import CORS
import os
import uuid
from werkzeug.utils import secure_filename

app = Flask(__name__)
CORS(app)  # å…è®¸è·¨åŸŸè¯·æ±‚

UPLOAD_FOLDER = 'uploads'
RESULT_FOLDER = 'results'
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(RESULT_FOLDER, exist_ok=True)

model = YOLO('yolov8n.pt')
db = DetectionDatabase()

@app.route('/api/detect/image', methods=['POST'])
def api_detect_image():
    """å›¾ç‰‡æ£€æµ‹API"""
    try:
        if 'image' not in request.files:
            return jsonify({'error': 'æ²¡æœ‰ä¸Šä¼ å›¾ç‰‡'}), 400
            
        file = request.files['image']
        if file.filename == '':
            return jsonify({'error': 'æ²¡æœ‰é€‰æ‹©æ–‡ä»¶'}), 400
        
        # ä¿å­˜ä¸Šä¼ çš„å›¾ç‰‡
        filename = secure_filename(file.filename)
        unique_filename = f"{uuid.uuid4()}_{filename}"
        image_path = os.path.join(UPLOAD_FOLDER, unique_filename)
        file.save(image_path)
        
        # æ‰§è¡Œæ£€æµ‹
        results = model(image_path)
        
        # æå–æ£€æµ‹ç»“æœ
        detections = []
        for box in results[0].boxes:
            x1, y1, x2, y2 = box.xyxy[0].tolist()
            confidence = box.conf[0].item()
            class_name = results[0].names[int(box.cls[0].item())]
            
            detections.append({
                'class_name': class_name,
                'confidence': round(confidence, 3),
                'bbox': {
                    'x1': int(x1), 'y1': int(y1),
                    'x2': int(x2), 'y2': int(y2)
                }
            })
        
        # ä¿å­˜ç»“æœå›¾ç‰‡
        result_filename = f"result_{unique_filename}"
        result_path = os.path.join(RESULT_FOLDER, result_filename)
        results[0].save(result_path)
        
        # ä¿å­˜åˆ°æ•°æ®åº“
        detection_id = db.save_detection(image_path, detections)
        
        return jsonify({
            'success': True,
            'detection_id': detection_id,
            'detections': detections,
            'total_objects': len(detections),
            'result_image_url': f'/api/result/{result_filename}'
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/result/<filename>')
def get_result_image(filename):
    """è·å–ç»“æœå›¾ç‰‡"""
    return send_from_directory(RESULT_FOLDER, filename)

@app.route('/api/history')
def get_detection_history():
    """è·å–æ£€æµ‹å†å²"""
    limit = request.args.get('limit', 10, type=int)
    history = db.get_detection_history(limit)
    
    return jsonify({
        'history': [
            {
                'id': h[0],
                'image_path': h[1],
                'detection_time': h[2],
                'total_objects': h[3],
                'confidence_avg': h[4]
            } for h in history
        ]
    })

@app.route('/api/statistics')
def get_statistics():
    """è·å–ç»Ÿè®¡ä¿¡æ¯"""
    stats = db.get_class_statistics()
    
    return jsonify({
        'class_statistics': [
            {
                'class_name': s[0],
                'count': s[1],
                'avg_confidence': round(s[2], 3)
            } for s in stats
        ]
    })

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)
```

---

## ğŸš€ æ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆ

### 1. æ¨¡å‹ç¼“å­˜å’Œé¢„çƒ­
```python
class OptimizedDetector:
    def __init__(self, model_path='yolov8n.pt'):
        self.model = YOLO(model_path)
        self.warmup()
        
    def warmup(self):
        """æ¨¡å‹é¢„çƒ­"""
        import numpy as np
        dummy_image = np.zeros((640, 640, 3), dtype=np.uint8)
        self.model(dummy_image)  # é¢„çƒ­æ¨ç†
        print("âœ… æ¨¡å‹é¢„çƒ­å®Œæˆ")
        
    def detect_optimized(self, image, conf_threshold=0.5):
        """ä¼˜åŒ–çš„æ£€æµ‹æ–¹æ³•"""
        results = self.model(image, conf=conf_threshold, verbose=False)
        
        detections = []
        if results[0].boxes is not None:
            for box in results[0].boxes:
                x1, y1, x2, y2 = box.xyxy[0].tolist()
                confidence = box.conf[0].item()
                class_name = results[0].names[int(box.cls[0].item())]
                
                detections.append({
                    'class_name': class_name,
                    'confidence': confidence,
                    'bbox': [int(x1), int(y1), int(x2), int(y2)]
                })
        
        return detections

# å…¨å±€æ¨¡å‹å®ä¾‹ï¼ˆé¿å…é‡å¤åŠ è½½ï¼‰
detector = OptimizedDetector()
```

---

## ğŸ“‹ å®Œæ•´é¡¹ç›®ç»“æ„

```
yolo_detection_project/
â”œâ”€â”€ app.py                      # Flaskä¸»åº”ç”¨
â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ detector.py            # æ£€æµ‹å™¨ç±»
â”‚   â”œâ”€â”€ database.py            # æ•°æ®åº“æ“ä½œ
â”‚   â””â”€â”€ realtime.py            # å®æ—¶æ£€æµ‹
â”œâ”€â”€ static/
â”‚   â”œâ”€â”€ css/
â”‚   â”‚   â””â”€â”€ style.css
â”‚   â”œâ”€â”€ js/
â”‚   â”‚   â””â”€â”€ app.js
â”‚   â””â”€â”€ images/
â”œâ”€â”€ templates/
â”‚   â”œâ”€â”€ index.html             # ä¸»é¡µé¢
â”‚   â”œâ”€â”€ history.html           # å†å²è®°å½•
â”‚   â””â”€â”€ statistics.html        # ç»Ÿè®¡é¡µé¢
â”œâ”€â”€ uploads/                   # ä¸Šä¼ å›¾ç‰‡ç›®å½•
â”œâ”€â”€ results/                   # ç»“æœå›¾ç‰‡ç›®å½•
â”œâ”€â”€ requirements.txt           # Pythonä¾èµ–
â”œâ”€â”€ config.py                  # é…ç½®æ–‡ä»¶
â”œâ”€â”€ docker-compose.yml         # Dockeré…ç½®
â””â”€â”€ README.md                  # é¡¹ç›®è¯´æ˜
```

---

## ğŸ¯ å…·ä½“åº”ç”¨åœºæ™¯

### 1. å®‰é˜²ç›‘æ§ç³»ç»Ÿ
```python
class SecurityMonitor:
    def __init__(self):
        self.detector = RealTimeDetector()
        self.detector.set_detection_callback(self.security_alert)
        
    def security_alert(self, detections):
        """å®‰å…¨è­¦æŠ¥å›è°ƒ"""
        person_count = sum(1 for d in detections if d['class_name'] == 'person')
        
        if person_count > 0:
            print(f"ğŸš¨ æ£€æµ‹åˆ° {person_count} ä¸ªäººå‘˜")
            # å¯ä»¥å‘é€é‚®ä»¶ã€çŸ­ä¿¡ç­‰è­¦æŠ¥
            
    def start_monitoring(self):
        print("ğŸ›¡ï¸ å®‰é˜²ç›‘æ§ç³»ç»Ÿå¯åŠ¨")
        self.detector.start()
```

### 2. å®¢æµç»Ÿè®¡ç³»ç»Ÿ
```python
class CustomerCounter:
    def __init__(self):
        self.total_count = 0
        self.current_count = 0
        
    def count_people(self, detections):
        """ç»Ÿè®¡äººæ•°"""
        person_count = sum(1 for d in detections if d['class_name'] == 'person')
        self.current_count = person_count
        
        # è®°å½•åˆ°æ•°æ®åº“
        timestamp = datetime.now()
        # ä¿å­˜ç»Ÿè®¡æ•°æ®...
        
        print(f"ğŸ‘¥ å½“å‰äººæ•°: {person_count}")
```

### 3. è‡ªåŠ¨è´¨æ£€ç³»ç»Ÿ
```python
class QualityInspector:
    def __init__(self, target_classes):
        self.model = YOLO('yolov8n.pt')
        self.target_classes = target_classes
        
    def inspect_product(self, image_path):
        """äº§å“è´¨æ£€"""
        results = self.model(image_path)
        
        detected_classes = set()
        for box in results[0].boxes:
            class_name = results[0].names[int(box.cls[0].item())]
            detected_classes.add(class_name)
        
        # æ£€æŸ¥æ˜¯å¦åŒ…å«ç›®æ ‡ç‰©ä½“
        is_qualified = all(cls in detected_classes for cls in self.target_classes)
        
        return {
            'qualified': is_qualified,
            'detected_classes': list(detected_classes),
            'missing_classes': [cls for cls in self.target_classes if cls not in detected_classes]
        }
```

---

## ğŸ“ˆ ç›‘æ§å’Œè¿ç»´

### 1. æ€§èƒ½ç›‘æ§
```python
import time
import psutil
from functools import wraps

def monitor_performance(func):
    """æ€§èƒ½ç›‘æ§è£…é¥°å™¨"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        start_memory = psutil.virtual_memory().used
        
        result = func(*args, **kwargs)
        
        end_time = time.time()
        end_memory = psutil.virtual_memory().used
        
        print(f"â±ï¸ æ‰§è¡Œæ—¶é—´: {end_time - start_time:.2f}ç§’")
        print(f"ğŸ’¾ å†…å­˜ä½¿ç”¨: {(end_memory - start_memory) / 1024 / 1024:.2f}MB")
        
        return result
    return wrapper

@monitor_performance
def detect_with_monitoring(image_path):
    model = YOLO('yolov8n.pt')
    results = model(image_path)
    return results
```

ç°åœ¨ä½ å·²ç»æœ‰äº†å®Œæ•´çš„YOLOå·¥ç¨‹é›†æˆæ–¹æ¡ˆï¼æ ¹æ®ä½ çš„å…·ä½“éœ€æ±‚é€‰æ‹©åˆé€‚çš„é›†æˆæ–¹å¼ï¼š

**ğŸš€ å¿«é€Ÿå¼€å§‹å»ºè®®ï¼š**
1. å…ˆè¯•è¯• **Webåº”ç”¨** ç‰ˆæœ¬ï¼Œæœ€å®¹æ˜“çœ‹åˆ°æ•ˆæœ
2. å¦‚æœéœ€è¦å®æ—¶å¤„ç†ï¼Œä½¿ç”¨ **æ‘„åƒå¤´æ£€æµ‹** ç‰ˆæœ¬  
3. å¦‚æœè¦åšæ•°æ®åˆ†æï¼ŒåŠ ä¸Š **æ•°æ®åº“é›†æˆ**
4. ç”Ÿäº§ç¯å¢ƒæ¨èä½¿ç”¨ **APIæ¥å£** + **Dockeréƒ¨ç½²**

éœ€è¦æˆ‘è¯¦ç»†è§£é‡Šä»»ä½•ä¸€ä¸ªæ–¹æ¡ˆçš„å…·ä½“å®ç°å—ï¼Ÿ 