# Flowable工作流可视化实时节点显示方案

## 🎯 需求分析

根据你提供的审批界面和流程图，需要实现：
1. **实时显示当前审批节点**：在流程图中高亮显示当前执行的节点
2. **流程图可视化**：展示完整的工作流程图
3. **节点状态标识**：区分已完成、进行中、待执行的节点
4. **动态更新**：审批状态变化时实时更新显示

---

## 🏗️ 技术架构方案

### 整体架构
```
前端展示层 (Vue/React + SVG/Canvas)
     ↓
后端API层 (Spring Boot + Flowable)
     ↓
Flowable引擎 (流程实例 + 历史数据)
     ↓
数据库层 (MySQL/PostgreSQL)
```

### 核心组件
1. **流程图渲染引擎** - 基于BPMN.js或自定义SVG
2. **实时状态服务** - WebSocket/SSE推送
3. **流程查询服务** - Flowable API封装
4. **前端可视化组件** - 交互式流程图展示

---

## 💡 实现方案

### 方案一：基于BPMN.js (推荐)

#### 1. 后端实现

**Maven依赖**
```xml
<dependencies>
    <!-- Flowable -->
    <dependency>
        <groupId>org.flowable</groupId>
        <artifactId>flowable-spring-boot-starter</artifactId>
        <version>6.8.0</version>
    </dependency>
    
    <!-- WebSocket -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-websocket</artifactId>
    </dependency>
</dependencies>
```

**流程状态查询服务**
```java
@RestController
@RequestMapping("/api/workflow")
public class WorkflowController {
    
    @Autowired
    private RuntimeService runtimeService;
    
    @Autowired
    private HistoryService historyService;
    
    @Autowired
    private RepositoryService repositoryService;
    
    /**
     * 获取流程图XML
     */
    @GetMapping("/process-definition/{processDefinitionId}/xml")
    public ResponseEntity<String> getProcessDefinitionXml(@PathVariable String processDefinitionId) {
        try {
            BpmnModel bpmnModel = repositoryService.getBpmnModel(processDefinitionId);
            byte[] xmlBytes = new BpmnXMLConverter().convertToXML(bpmnModel);
            String xml = new String(xmlBytes, StandardCharsets.UTF_8);
            return ResponseEntity.ok(xml);
        } catch (Exception e) {
            return ResponseEntity.status(500).body("获取流程图失败");
        }
    }
    
    /**
     * 获取流程实例状态
     */
    @GetMapping("/process-instance/{processInstanceId}/status")
    public ResponseEntity<ProcessInstanceStatus> getProcessInstanceStatus(@PathVariable String processInstanceId) {
        ProcessInstanceStatus status = new ProcessInstanceStatus();
        
        // 获取当前活动节点
        List<Execution> executions = runtimeService.createExecutionQuery()
                .processInstanceId(processInstanceId)
                .list();
        
        Set<String> activeActivityIds = new HashSet<>();
        for (Execution execution : executions) {
            if (execution.getActivityId() != null) {
                activeActivityIds.add(execution.getActivityId());
            }
        }
        
        // 获取已完成的活动节点
        List<HistoricActivityInstance> completedActivities = historyService
                .createHistoricActivityInstanceQuery()
                .processInstanceId(processInstanceId)
                .finished()
                .list();
        
        Set<String> completedActivityIds = completedActivities.stream()
                .map(HistoricActivityInstance::getActivityId)
                .collect(Collectors.toSet());
        
        status.setActiveActivityIds(activeActivityIds);
        status.setCompletedActivityIds(completedActivityIds);
        status.setProcessInstanceId(processInstanceId);
        
        return ResponseEntity.ok(status);
    }
    
    /**
     * 获取流程实例详细信息
     */
    @GetMapping("/process-instance/{processInstanceId}/details")
    public ResponseEntity<ProcessInstanceDetails> getProcessInstanceDetails(@PathVariable String processInstanceId) {
        ProcessInstanceDetails details = new ProcessInstanceDetails();
        
        // 基本信息
        ProcessInstance processInstance = runtimeService.createProcessInstanceQuery()
                .processInstanceId(processInstanceId)
                .singleResult();
        
        if (processInstance != null) {
            details.setProcessInstanceId(processInstanceId);
            details.setProcessDefinitionId(processInstance.getProcessDefinitionId());
            details.setStartTime(processInstance.getStartTime());
            details.setStartUserId(processInstance.getStartUserId());
        }
        
        // 当前任务信息
        List<Task> currentTasks = taskService.createTaskQuery()
                .processInstanceId(processInstanceId)
                .list();
        
        List<TaskInfo> taskInfos = currentTasks.stream()
                .map(task -> {
                    TaskInfo taskInfo = new TaskInfo();
                    taskInfo.setTaskId(task.getId());
                    taskInfo.setTaskName(task.getName());
                    taskInfo.setAssignee(task.getAssignee());
                    taskInfo.setCandidateUsers(taskService.getIdentityLinksForTask(task.getId())
                            .stream()
                            .filter(link -> IdentityLinkType.CANDIDATE.equals(link.getType()))
                            .map(IdentityLink::getUserId)
                            .collect(Collectors.toList()));
                    return taskInfo;
                })
                .collect(Collectors.toList());
        
        details.setCurrentTasks(taskInfos);
        
        // 历史审批记录
        List<HistoricTaskInstance> historicTasks = historyService
                .createHistoricTaskInstanceQuery()
                .processInstanceId(processInstanceId)
                .finished()
                .orderByHistoricTaskInstanceEndTime()
                .asc()
                .list();
        
        List<HistoricTaskInfo> historicTaskInfos = historicTasks.stream()
                .map(historic -> {
                    HistoricTaskInfo info = new HistoricTaskInfo();
                    info.setTaskName(historic.getName());
                    info.setAssignee(historic.getAssignee());
                    info.setStartTime(historic.getStartTime());
                    info.setEndTime(historic.getEndTime());
                    
                    // 获取审批意见
                    List<Comment> comments = taskService.getTaskComments(historic.getId());
                    if (!comments.isEmpty()) {
                        info.setComment(comments.get(0).getFullMessage());
                    }
                    
                    return info;
                })
                .collect(Collectors.toList());
        
        details.setHistoricTasks(historicTaskInfos);
        
        return ResponseEntity.ok(details);
    }
}
```

**数据传输对象**
```java
@Data
public class ProcessInstanceStatus {
    private String processInstanceId;
    private Set<String> activeActivityIds;      // 当前活动节点
    private Set<String> completedActivityIds;   // 已完成节点
    private Date lastUpdateTime;
}

@Data
public class ProcessInstanceDetails {
    private String processInstanceId;
    private String processDefinitionId;
    private Date startTime;
    private String startUserId;
    private List<TaskInfo> currentTasks;
    private List<HistoricTaskInfo> historicTasks;
}

@Data
public class TaskInfo {
    private String taskId;
    private String taskName;
    private String assignee;
    private List<String> candidateUsers;
    private Date createTime;
}

@Data
public class HistoricTaskInfo {
    private String taskName;
    private String assignee;
    private Date startTime;
    private Date endTime;
    private String comment;
    private String result; // 同意/拒绝
}
```

#### 2. 前端实现

**HTML结构**
```html
<!DOCTYPE html>
<html>
<head>
    <title>工作流可视化</title>
    <script src="https://unpkg.com/bpmn-js@11.0.0/dist/bpmn-viewer.development.js"></script>
    <style>
        .process-container {
            display: flex;
            height: 100vh;
        }
        
        .process-diagram {
            flex: 1;
            border: 1px solid #ccc;
        }
        
        .process-info {
            width: 300px;
            padding: 20px;
            border-left: 1px solid #ccc;
            overflow-y: auto;
        }
        
        /* 节点状态样式 */
        .highlight-active {
            fill: #52c41a !important;
            stroke: #52c41a !important;
            stroke-width: 3px !important;
        }
        
        .highlight-completed {
            fill: #1890ff !important;
            stroke: #1890ff !important;
            stroke-width: 2px !important;
        }
        
        .highlight-pending {
            fill: #d9d9d9 !important;
            stroke: #d9d9d9 !important;
        }
    </style>
</head>
<body>
    <div class="process-container">
        <div id="canvas" class="process-diagram"></div>
        <div class="process-info">
            <h3>流程信息</h3>
            <div id="processInfo"></div>
            
            <h3>当前任务</h3>
            <div id="currentTasks"></div>
            
            <h3>审批历史</h3>
            <div id="approvalHistory"></div>
        </div>
    </div>

    <script src="process-viewer.js"></script>
</body>
</html>
```

**JavaScript实现**
```javascript
class ProcessViewer {
    constructor(containerId, processInstanceId) {
        this.containerId = containerId;
        this.processInstanceId = processInstanceId;
        this.viewer = new BpmnJS({
            container: `#${containerId}`
        });
        
        this.initWebSocket();
        this.loadProcess();
    }
    
    async loadProcess() {
        try {
            // 获取流程定义ID
            const instanceDetails = await this.fetchProcessInstanceDetails();
            const processDefinitionId = instanceDetails.processDefinitionId;
            
            // 加载流程图XML
            const xmlResponse = await fetch(`/api/workflow/process-definition/${processDefinitionId}/xml`);
            const xml = await xmlResponse.text();
            
            // 渲染流程图
            await this.viewer.importXML(xml);
            
            // 加载并显示当前状态
            await this.loadAndDisplayStatus();
            
            // 显示流程信息
            this.displayProcessInfo(instanceDetails);
            
        } catch (error) {
            console.error('加载流程图失败:', error);
        }
    }
    
    async loadAndDisplayStatus() {
        try {
            const response = await fetch(`/api/workflow/process-instance/${this.processInstanceId}/status`);
            const status = await response.json();
            
            this.highlightNodes(status);
            
        } catch (error) {
            console.error('加载流程状态失败:', error);
        }
    }
    
    highlightNodes(status) {
        const canvas = this.viewer.get('canvas');
        const elementRegistry = this.viewer.get('elementRegistry');
        
        // 清除之前的高亮
        elementRegistry.getAll().forEach(element => {
            if (element.type !== 'label') {
                canvas.removeMarker(element.id, 'highlight-active');
                canvas.removeMarker(element.id, 'highlight-completed');
                canvas.removeMarker(element.id, 'highlight-pending');
            }
        });
        
        // 高亮当前活动节点
        status.activeActivityIds.forEach(activityId => {
            canvas.addMarker(activityId, 'highlight-active');
        });
        
        // 高亮已完成节点
        status.completedActivityIds.forEach(activityId => {
            canvas.addMarker(activityId, 'highlight-completed');
        });
        
        // 其他节点设为待执行状态
        elementRegistry.getAll().forEach(element => {
            if (element.type !== 'label' && 
                !status.activeActivityIds.has(element.id) && 
                !status.completedActivityIds.has(element.id)) {
                canvas.addMarker(element.id, 'highlight-pending');
            }
        });
    }
    
    async fetchProcessInstanceDetails() {
        const response = await fetch(`/api/workflow/process-instance/${this.processInstanceId}/details`);
        return await response.json();
    }
    
    displayProcessInfo(details) {
        const processInfoDiv = document.getElementById('processInfo');
        processInfoDiv.innerHTML = `
            <p><strong>流程实例ID:</strong> ${details.processInstanceId}</p>
            <p><strong>开始时间:</strong> ${new Date(details.startTime).toLocaleString()}</p>
            <p><strong>发起人:</strong> ${details.startUserId}</p>
        `;
        
        // 显示当前任务
        const currentTasksDiv = document.getElementById('currentTasks');
        if (details.currentTasks && details.currentTasks.length > 0) {
            currentTasksDiv.innerHTML = details.currentTasks.map(task => `
                <div class="task-item">
                    <p><strong>${task.taskName}</strong></p>
                    <p>处理人: ${task.assignee || '待分配'}</p>
                    <p>候选人: ${task.candidateUsers.join(', ')}</p>
                </div>
            `).join('');
        } else {
            currentTasksDiv.innerHTML = '<p>无当前任务</p>';
        }
        
        // 显示审批历史
        const historyDiv = document.getElementById('approvalHistory');
        if (details.historicTasks && details.historicTasks.length > 0) {
            historyDiv.innerHTML = details.historicTasks.map(task => `
                <div class="history-item">
                    <p><strong>${task.taskName}</strong></p>
                    <p>处理人: ${task.assignee}</p>
                    <p>处理时间: ${new Date(task.endTime).toLocaleString()}</p>
                    <p>意见: ${task.comment || '无'}</p>
                </div>
            `).join('');
        } else {
            historyDiv.innerHTML = '<p>无审批历史</p>';
        }
    }
    
    initWebSocket() {
        const wsUrl = `ws://localhost:8080/websocket/process-instance?processInstanceId=${this.processInstanceId}`;
        this.websocket = new WebSocket(wsUrl);
        
        this.websocket.onmessage = (event) => {
            const status = JSON.parse(event.data);
            this.highlightNodes(status);
            
            // 刷新流程信息
            this.fetchProcessInstanceDetails().then(details => {
                this.displayProcessInfo(details);
            });
        };
        
        this.websocket.onerror = (error) => {
            console.error('WebSocket连接错误:', error);
        };
    }
    
    destroy() {
        if (this.websocket) {
            this.websocket.close();
        }
        this.viewer.destroy();
    }
}

// 使用示例
document.addEventListener('DOMContentLoaded', function() {
    // 从URL参数或其他方式获取流程实例ID
    const urlParams = new URLSearchParams(window.location.search);
    const processInstanceId = urlParams.get('processInstanceId') || 'FLOW_ID_20250613140638182728';
    
    const viewer = new ProcessViewer('canvas', processInstanceId);
    
    // 页面卸载时清理资源
    window.addEventListener('beforeunload', () => {
        viewer.destroy();
    });
});
```

### WebSocket实时推送实现

```java
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {
    
    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(new ProcessInstanceWebSocketHandler(), "/websocket/process-instance")
                .setAllowedOrigins("*");
    }
}

@Component
public class ProcessInstanceWebSocketHandler extends TextWebSocketHandler {
    
    private final Map<String, Set<WebSocketSession>> processInstanceSessions = new ConcurrentHashMap<>();
    
    @Override
    public void afterConnectionEstablished(WebSocketSession session) throws Exception {
        String processInstanceId = getProcessInstanceId(session);
        processInstanceSessions.computeIfAbsent(processInstanceId, k -> ConcurrentHashMap.newKeySet())
                .add(session);
    }
    
    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
        String processInstanceId = getProcessInstanceId(session);
        Set<WebSocketSession> sessions = processInstanceSessions.get(processInstanceId);
        if (sessions != null) {
            sessions.remove(session);
            if (sessions.isEmpty()) {
                processInstanceSessions.remove(processInstanceId);
            }
        }
    }
    
    public void notifyProcessInstanceUpdate(String processInstanceId, ProcessInstanceStatus status) {
        Set<WebSocketSession> sessions = processInstanceSessions.get(processInstanceId);
        if (sessions != null) {
            String message = JSON.toJSONString(status);
            sessions.forEach(session -> {
                try {
                    session.sendMessage(new TextMessage(message));
                } catch (IOException e) {
                    log.error("发送WebSocket消息失败", e);
                }
            });
        }
    }
    
    private String getProcessInstanceId(WebSocketSession session) {
        return Objects.requireNonNull(session.getUri())
                .getQuery()
                .split("processInstanceId=")[1];
    }
}
```

### 流程事件监听

```java
@Component
public class ProcessEventListener implements FlowableEventListener {
    
    @Autowired
    private ProcessInstanceWebSocketHandler webSocketHandler;
    
    @Autowired
    private WorkflowController workflowController;
    
    @Override
    public void onEvent(FlowableEvent event) {
        if (event.getType() == FlowableEngineEventType.TASK_CREATED ||
            event.getType() == FlowableEngineEventType.TASK_COMPLETED ||
            event.getType() == FlowableEngineEventType.ACTIVITY_STARTED ||
            event.getType() == FlowableEngineEventType.ACTIVITY_COMPLETED) {
            
            String processInstanceId = event.getProcessInstanceId();
            
            // 获取最新状态
            ResponseEntity<ProcessInstanceStatus> response = 
                workflowController.getProcessInstanceStatus(processInstanceId);
            
            if (response.getStatusCode().is2xxSuccessful()) {
                // 通过WebSocket推送更新
                webSocketHandler.notifyProcessInstanceUpdate(processInstanceId, response.getBody());
            }
        }
    }
    
    @Override
    public boolean isFailOnException() {
        return false;
    }
}

@Configuration
public class FlowableConfig {
    
    @Bean
    public ProcessEventListener processEventListener() {
        return new ProcessEventListener();
    }
    
    @Bean
    public ProcessEngineConfigurationConfigurer processEngineConfigurationConfigurer(
            ProcessEventListener eventListener) {
        return configuration -> {
            configuration.setEventListeners(Arrays.asList(eventListener));
        };
    }
}
```

---

## 🎨 增强样式和用户体验

```css
/* 优化的CSS样式 */
.process-viewer-container {
    display: flex;
    height: 100vh;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.diagram-container {
    flex: 1;
    position: relative;
    border: 1px solid #e8e8e8;
    background-color: #fafafa;
}

.info-panel {
    width: 350px;
    background-color: #fff;
    border-left: 1px solid #e8e8e8;
    overflow-y: auto;
}

/* BPMN.js 节点状态样式 */
.highlight-active .djs-visual > rect,
.highlight-active .djs-visual > circle {
    fill: #52c41a !important;
    stroke: #389e0d !important;
    stroke-width: 3px !important;
    animation: pulse 2s infinite;
}

.highlight-completed .djs-visual > rect,
.highlight-completed .djs-visual > circle {
    fill: #1890ff !important;
    stroke: #096dd9 !important;
    stroke-width: 2px !important;
}

.highlight-pending .djs-visual > rect,
.highlight-pending .djs-visual > circle {
    fill: #f0f0f0 !important;
    stroke: #d9d9d9 !important;
    stroke-width: 1px !important;
}

@keyframes pulse {
    0% { stroke-width: 3px; }
    50% { stroke-width: 5px; }
    100% { stroke-width: 3px; }
}

.info-section {
    padding: 16px;
    border-bottom: 1px solid #f0f0f0;
}

.info-section h3 {
    margin: 0 0 12px 0;
    color: #262626;
    font-size: 16px;
    font-weight: 600;
}

.task-item, .history-item {
    padding: 12px;
    margin-bottom: 8px;
    background-color: #fafafa;
    border-radius: 6px;
    border-left: 3px solid #1890ff;
}

.task-item.active {
    border-left-color: #52c41a;
    background-color: #f6ffed;
}

.status-badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: 500;
}

.status-active {
    background-color: #f6ffed;
    color: #52c41a;
    border: 1px solid #b7eb8f;
}

.status-completed {
    background-color: #e6f7ff;
    color: #1890ff;
    border: 1px solid #91d5ff;
}
```

---

## 🚀 部署和集成

### 1. 后端配置

```yaml
# application.yml
flowable:
  database-schema-update: true
  history-level: full
  check-process-definitions: false
  
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/flowable
    username: root
    password: password
    driver-class-name: com.mysql.cj.jdbc.Driver
    
  websocket:
    allowed-origins: "*"

server:
  port: 8080
```

### 2. 前端集成示例

```javascript
// 在现有审批页面中集成
function initWorkflowViewer(processInstanceId) {
    // 创建容器
    const container = document.createElement('div');
    container.id = 'workflow-viewer-modal';
    container.innerHTML = `
        <div class="modal-overlay">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>流程进度</h3>
                    <button class="close-btn" onclick="closeWorkflowViewer()">×</button>
                </div>
                <div class="modal-body">
                    <div id="workflow-canvas" style="height: 500px;"></div>
                </div>
            </div>
        </div>
    `;
    
    document.body.appendChild(container);
    
    // 初始化流程查看器
    const viewer = new ProcessViewer('workflow-canvas', processInstanceId);
    
    return viewer;
}

function closeWorkflowViewer() {
    const modal = document.getElementById('workflow-viewer-modal');
    if (modal) {
        modal.remove();
    }
}

// 在审批列表中添加"查看流程"按钮
function addViewProcessButtons() {
    document.querySelectorAll('.approval-item').forEach(item => {
        const processInstanceId = item.dataset.processInstanceId;
        const button = document.createElement('button');
        button.textContent = '查看流程';
        button.onclick = () => initWorkflowViewer(processInstanceId);
        item.appendChild(button);
    });
}
```

---

## 🎯 总结

这个方案提供了完整的Flowable工作流可视化解决方案：

### 主要特性
1. **实时状态更新** - WebSocket推送，无需手动刷新
2. **专业流程图** - 基于BPMN.js的标准流程图渲染
3. **丰富的交互** - 节点高亮、状态区分、详细信息展示
4. **完整的API** - 流程状态查询、历史记录、任务信息
5. **事件驱动** - 基于Flowable事件监听器的自动更新

### 实施步骤
1. **后端开发** - 实现API接口和WebSocket服务
2. **前端集成** - 在现有页面中嵌入流程查看器
3. **样式定制** - 根据UI风格调整视觉效果
4. **测试验证** - 确保各种流程场景正常工作

### 技术优势
- 基于成熟的开源技术栈
- 标准的BPMN 2.0支持
- 高性能的实时更新机制
- 良好的可扩展性和维护性

这个方案能够完美满足甲方的需求，让用户实时看到审批流程的当前位置和历史进度！ 