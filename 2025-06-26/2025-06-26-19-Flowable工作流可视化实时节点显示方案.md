# Flowableå·¥ä½œæµå¯è§†åŒ–å®æ—¶èŠ‚ç‚¹æ˜¾ç¤ºæ–¹æ¡ˆ

## ğŸ¯ éœ€æ±‚åˆ†æ

æ ¹æ®ä½ æä¾›çš„å®¡æ‰¹ç•Œé¢å’Œæµç¨‹å›¾ï¼Œéœ€è¦å®ç°ï¼š
1. **å®æ—¶æ˜¾ç¤ºå½“å‰å®¡æ‰¹èŠ‚ç‚¹**ï¼šåœ¨æµç¨‹å›¾ä¸­é«˜äº®æ˜¾ç¤ºå½“å‰æ‰§è¡Œçš„èŠ‚ç‚¹
2. **æµç¨‹å›¾å¯è§†åŒ–**ï¼šå±•ç¤ºå®Œæ•´çš„å·¥ä½œæµç¨‹å›¾
3. **èŠ‚ç‚¹çŠ¶æ€æ ‡è¯†**ï¼šåŒºåˆ†å·²å®Œæˆã€è¿›è¡Œä¸­ã€å¾…æ‰§è¡Œçš„èŠ‚ç‚¹
4. **åŠ¨æ€æ›´æ–°**ï¼šå®¡æ‰¹çŠ¶æ€å˜åŒ–æ—¶å®æ—¶æ›´æ–°æ˜¾ç¤º

---

## ğŸ—ï¸ æŠ€æœ¯æ¶æ„æ–¹æ¡ˆ

### æ•´ä½“æ¶æ„
```
å‰ç«¯å±•ç¤ºå±‚ (Vue/React + SVG/Canvas)
     â†“
åç«¯APIå±‚ (Spring Boot + Flowable)
     â†“
Flowableå¼•æ“ (æµç¨‹å®ä¾‹ + å†å²æ•°æ®)
     â†“
æ•°æ®åº“å±‚ (MySQL/PostgreSQL)
```

### æ ¸å¿ƒç»„ä»¶
1. **æµç¨‹å›¾æ¸²æŸ“å¼•æ“** - åŸºäºBPMN.jsæˆ–è‡ªå®šä¹‰SVG
2. **å®æ—¶çŠ¶æ€æœåŠ¡** - WebSocket/SSEæ¨é€
3. **æµç¨‹æŸ¥è¯¢æœåŠ¡** - Flowable APIå°è£…
4. **å‰ç«¯å¯è§†åŒ–ç»„ä»¶** - äº¤äº’å¼æµç¨‹å›¾å±•ç¤º

---

## ğŸ’¡ å®ç°æ–¹æ¡ˆ

### æ–¹æ¡ˆä¸€ï¼šåŸºäºBPMN.js (æ¨è)

#### 1. åç«¯å®ç°

**Mavenä¾èµ–**
```xml
<dependencies>
    <!-- Flowable -->
    <dependency>
        <groupId>org.flowable</groupId>
        <artifactId>flowable-spring-boot-starter</artifactId>
        <version>6.8.0</version>
    </dependency>
    
    <!-- WebSocket -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-websocket</artifactId>
    </dependency>
</dependencies>
```

**æµç¨‹çŠ¶æ€æŸ¥è¯¢æœåŠ¡**
```java
@RestController
@RequestMapping("/api/workflow")
public class WorkflowController {
    
    @Autowired
    private RuntimeService runtimeService;
    
    @Autowired
    private HistoryService historyService;
    
    @Autowired
    private RepositoryService repositoryService;
    
    /**
     * è·å–æµç¨‹å›¾XML
     */
    @GetMapping("/process-definition/{processDefinitionId}/xml")
    public ResponseEntity<String> getProcessDefinitionXml(@PathVariable String processDefinitionId) {
        try {
            BpmnModel bpmnModel = repositoryService.getBpmnModel(processDefinitionId);
            byte[] xmlBytes = new BpmnXMLConverter().convertToXML(bpmnModel);
            String xml = new String(xmlBytes, StandardCharsets.UTF_8);
            return ResponseEntity.ok(xml);
        } catch (Exception e) {
            return ResponseEntity.status(500).body("è·å–æµç¨‹å›¾å¤±è´¥");
        }
    }
    
    /**
     * è·å–æµç¨‹å®ä¾‹çŠ¶æ€
     */
    @GetMapping("/process-instance/{processInstanceId}/status")
    public ResponseEntity<ProcessInstanceStatus> getProcessInstanceStatus(@PathVariable String processInstanceId) {
        ProcessInstanceStatus status = new ProcessInstanceStatus();
        
        // è·å–å½“å‰æ´»åŠ¨èŠ‚ç‚¹
        List<Execution> executions = runtimeService.createExecutionQuery()
                .processInstanceId(processInstanceId)
                .list();
        
        Set<String> activeActivityIds = new HashSet<>();
        for (Execution execution : executions) {
            if (execution.getActivityId() != null) {
                activeActivityIds.add(execution.getActivityId());
            }
        }
        
        // è·å–å·²å®Œæˆçš„æ´»åŠ¨èŠ‚ç‚¹
        List<HistoricActivityInstance> completedActivities = historyService
                .createHistoricActivityInstanceQuery()
                .processInstanceId(processInstanceId)
                .finished()
                .list();
        
        Set<String> completedActivityIds = completedActivities.stream()
                .map(HistoricActivityInstance::getActivityId)
                .collect(Collectors.toSet());
        
        status.setActiveActivityIds(activeActivityIds);
        status.setCompletedActivityIds(completedActivityIds);
        status.setProcessInstanceId(processInstanceId);
        
        return ResponseEntity.ok(status);
    }
    
    /**
     * è·å–æµç¨‹å®ä¾‹è¯¦ç»†ä¿¡æ¯
     */
    @GetMapping("/process-instance/{processInstanceId}/details")
    public ResponseEntity<ProcessInstanceDetails> getProcessInstanceDetails(@PathVariable String processInstanceId) {
        ProcessInstanceDetails details = new ProcessInstanceDetails();
        
        // åŸºæœ¬ä¿¡æ¯
        ProcessInstance processInstance = runtimeService.createProcessInstanceQuery()
                .processInstanceId(processInstanceId)
                .singleResult();
        
        if (processInstance != null) {
            details.setProcessInstanceId(processInstanceId);
            details.setProcessDefinitionId(processInstance.getProcessDefinitionId());
            details.setStartTime(processInstance.getStartTime());
            details.setStartUserId(processInstance.getStartUserId());
        }
        
        // å½“å‰ä»»åŠ¡ä¿¡æ¯
        List<Task> currentTasks = taskService.createTaskQuery()
                .processInstanceId(processInstanceId)
                .list();
        
        List<TaskInfo> taskInfos = currentTasks.stream()
                .map(task -> {
                    TaskInfo taskInfo = new TaskInfo();
                    taskInfo.setTaskId(task.getId());
                    taskInfo.setTaskName(task.getName());
                    taskInfo.setAssignee(task.getAssignee());
                    taskInfo.setCandidateUsers(taskService.getIdentityLinksForTask(task.getId())
                            .stream()
                            .filter(link -> IdentityLinkType.CANDIDATE.equals(link.getType()))
                            .map(IdentityLink::getUserId)
                            .collect(Collectors.toList()));
                    return taskInfo;
                })
                .collect(Collectors.toList());
        
        details.setCurrentTasks(taskInfos);
        
        // å†å²å®¡æ‰¹è®°å½•
        List<HistoricTaskInstance> historicTasks = historyService
                .createHistoricTaskInstanceQuery()
                .processInstanceId(processInstanceId)
                .finished()
                .orderByHistoricTaskInstanceEndTime()
                .asc()
                .list();
        
        List<HistoricTaskInfo> historicTaskInfos = historicTasks.stream()
                .map(historic -> {
                    HistoricTaskInfo info = new HistoricTaskInfo();
                    info.setTaskName(historic.getName());
                    info.setAssignee(historic.getAssignee());
                    info.setStartTime(historic.getStartTime());
                    info.setEndTime(historic.getEndTime());
                    
                    // è·å–å®¡æ‰¹æ„è§
                    List<Comment> comments = taskService.getTaskComments(historic.getId());
                    if (!comments.isEmpty()) {
                        info.setComment(comments.get(0).getFullMessage());
                    }
                    
                    return info;
                })
                .collect(Collectors.toList());
        
        details.setHistoricTasks(historicTaskInfos);
        
        return ResponseEntity.ok(details);
    }
}
```

**æ•°æ®ä¼ è¾“å¯¹è±¡**
```java
@Data
public class ProcessInstanceStatus {
    private String processInstanceId;
    private Set<String> activeActivityIds;      // å½“å‰æ´»åŠ¨èŠ‚ç‚¹
    private Set<String> completedActivityIds;   // å·²å®ŒæˆèŠ‚ç‚¹
    private Date lastUpdateTime;
}

@Data
public class ProcessInstanceDetails {
    private String processInstanceId;
    private String processDefinitionId;
    private Date startTime;
    private String startUserId;
    private List<TaskInfo> currentTasks;
    private List<HistoricTaskInfo> historicTasks;
}

@Data
public class TaskInfo {
    private String taskId;
    private String taskName;
    private String assignee;
    private List<String> candidateUsers;
    private Date createTime;
}

@Data
public class HistoricTaskInfo {
    private String taskName;
    private String assignee;
    private Date startTime;
    private Date endTime;
    private String comment;
    private String result; // åŒæ„/æ‹’ç»
}
```

#### 2. å‰ç«¯å®ç°

**HTMLç»“æ„**
```html
<!DOCTYPE html>
<html>
<head>
    <title>å·¥ä½œæµå¯è§†åŒ–</title>
    <script src="https://unpkg.com/bpmn-js@11.0.0/dist/bpmn-viewer.development.js"></script>
    <style>
        .process-container {
            display: flex;
            height: 100vh;
        }
        
        .process-diagram {
            flex: 1;
            border: 1px solid #ccc;
        }
        
        .process-info {
            width: 300px;
            padding: 20px;
            border-left: 1px solid #ccc;
            overflow-y: auto;
        }
        
        /* èŠ‚ç‚¹çŠ¶æ€æ ·å¼ */
        .highlight-active {
            fill: #52c41a !important;
            stroke: #52c41a !important;
            stroke-width: 3px !important;
        }
        
        .highlight-completed {
            fill: #1890ff !important;
            stroke: #1890ff !important;
            stroke-width: 2px !important;
        }
        
        .highlight-pending {
            fill: #d9d9d9 !important;
            stroke: #d9d9d9 !important;
        }
    </style>
</head>
<body>
    <div class="process-container">
        <div id="canvas" class="process-diagram"></div>
        <div class="process-info">
            <h3>æµç¨‹ä¿¡æ¯</h3>
            <div id="processInfo"></div>
            
            <h3>å½“å‰ä»»åŠ¡</h3>
            <div id="currentTasks"></div>
            
            <h3>å®¡æ‰¹å†å²</h3>
            <div id="approvalHistory"></div>
        </div>
    </div>

    <script src="process-viewer.js"></script>
</body>
</html>
```

**JavaScriptå®ç°**
```javascript
class ProcessViewer {
    constructor(containerId, processInstanceId) {
        this.containerId = containerId;
        this.processInstanceId = processInstanceId;
        this.viewer = new BpmnJS({
            container: `#${containerId}`
        });
        
        this.initWebSocket();
        this.loadProcess();
    }
    
    async loadProcess() {
        try {
            // è·å–æµç¨‹å®šä¹‰ID
            const instanceDetails = await this.fetchProcessInstanceDetails();
            const processDefinitionId = instanceDetails.processDefinitionId;
            
            // åŠ è½½æµç¨‹å›¾XML
            const xmlResponse = await fetch(`/api/workflow/process-definition/${processDefinitionId}/xml`);
            const xml = await xmlResponse.text();
            
            // æ¸²æŸ“æµç¨‹å›¾
            await this.viewer.importXML(xml);
            
            // åŠ è½½å¹¶æ˜¾ç¤ºå½“å‰çŠ¶æ€
            await this.loadAndDisplayStatus();
            
            // æ˜¾ç¤ºæµç¨‹ä¿¡æ¯
            this.displayProcessInfo(instanceDetails);
            
        } catch (error) {
            console.error('åŠ è½½æµç¨‹å›¾å¤±è´¥:', error);
        }
    }
    
    async loadAndDisplayStatus() {
        try {
            const response = await fetch(`/api/workflow/process-instance/${this.processInstanceId}/status`);
            const status = await response.json();
            
            this.highlightNodes(status);
            
        } catch (error) {
            console.error('åŠ è½½æµç¨‹çŠ¶æ€å¤±è´¥:', error);
        }
    }
    
    highlightNodes(status) {
        const canvas = this.viewer.get('canvas');
        const elementRegistry = this.viewer.get('elementRegistry');
        
        // æ¸…é™¤ä¹‹å‰çš„é«˜äº®
        elementRegistry.getAll().forEach(element => {
            if (element.type !== 'label') {
                canvas.removeMarker(element.id, 'highlight-active');
                canvas.removeMarker(element.id, 'highlight-completed');
                canvas.removeMarker(element.id, 'highlight-pending');
            }
        });
        
        // é«˜äº®å½“å‰æ´»åŠ¨èŠ‚ç‚¹
        status.activeActivityIds.forEach(activityId => {
            canvas.addMarker(activityId, 'highlight-active');
        });
        
        // é«˜äº®å·²å®ŒæˆèŠ‚ç‚¹
        status.completedActivityIds.forEach(activityId => {
            canvas.addMarker(activityId, 'highlight-completed');
        });
        
        // å…¶ä»–èŠ‚ç‚¹è®¾ä¸ºå¾…æ‰§è¡ŒçŠ¶æ€
        elementRegistry.getAll().forEach(element => {
            if (element.type !== 'label' && 
                !status.activeActivityIds.has(element.id) && 
                !status.completedActivityIds.has(element.id)) {
                canvas.addMarker(element.id, 'highlight-pending');
            }
        });
    }
    
    async fetchProcessInstanceDetails() {
        const response = await fetch(`/api/workflow/process-instance/${this.processInstanceId}/details`);
        return await response.json();
    }
    
    displayProcessInfo(details) {
        const processInfoDiv = document.getElementById('processInfo');
        processInfoDiv.innerHTML = `
            <p><strong>æµç¨‹å®ä¾‹ID:</strong> ${details.processInstanceId}</p>
            <p><strong>å¼€å§‹æ—¶é—´:</strong> ${new Date(details.startTime).toLocaleString()}</p>
            <p><strong>å‘èµ·äºº:</strong> ${details.startUserId}</p>
        `;
        
        // æ˜¾ç¤ºå½“å‰ä»»åŠ¡
        const currentTasksDiv = document.getElementById('currentTasks');
        if (details.currentTasks && details.currentTasks.length > 0) {
            currentTasksDiv.innerHTML = details.currentTasks.map(task => `
                <div class="task-item">
                    <p><strong>${task.taskName}</strong></p>
                    <p>å¤„ç†äºº: ${task.assignee || 'å¾…åˆ†é…'}</p>
                    <p>å€™é€‰äºº: ${task.candidateUsers.join(', ')}</p>
                </div>
            `).join('');
        } else {
            currentTasksDiv.innerHTML = '<p>æ— å½“å‰ä»»åŠ¡</p>';
        }
        
        // æ˜¾ç¤ºå®¡æ‰¹å†å²
        const historyDiv = document.getElementById('approvalHistory');
        if (details.historicTasks && details.historicTasks.length > 0) {
            historyDiv.innerHTML = details.historicTasks.map(task => `
                <div class="history-item">
                    <p><strong>${task.taskName}</strong></p>
                    <p>å¤„ç†äºº: ${task.assignee}</p>
                    <p>å¤„ç†æ—¶é—´: ${new Date(task.endTime).toLocaleString()}</p>
                    <p>æ„è§: ${task.comment || 'æ— '}</p>
                </div>
            `).join('');
        } else {
            historyDiv.innerHTML = '<p>æ— å®¡æ‰¹å†å²</p>';
        }
    }
    
    initWebSocket() {
        const wsUrl = `ws://localhost:8080/websocket/process-instance?processInstanceId=${this.processInstanceId}`;
        this.websocket = new WebSocket(wsUrl);
        
        this.websocket.onmessage = (event) => {
            const status = JSON.parse(event.data);
            this.highlightNodes(status);
            
            // åˆ·æ–°æµç¨‹ä¿¡æ¯
            this.fetchProcessInstanceDetails().then(details => {
                this.displayProcessInfo(details);
            });
        };
        
        this.websocket.onerror = (error) => {
            console.error('WebSocketè¿æ¥é”™è¯¯:', error);
        };
    }
    
    destroy() {
        if (this.websocket) {
            this.websocket.close();
        }
        this.viewer.destroy();
    }
}

// ä½¿ç”¨ç¤ºä¾‹
document.addEventListener('DOMContentLoaded', function() {
    // ä»URLå‚æ•°æˆ–å…¶ä»–æ–¹å¼è·å–æµç¨‹å®ä¾‹ID
    const urlParams = new URLSearchParams(window.location.search);
    const processInstanceId = urlParams.get('processInstanceId') || 'FLOW_ID_20250613140638182728';
    
    const viewer = new ProcessViewer('canvas', processInstanceId);
    
    // é¡µé¢å¸è½½æ—¶æ¸…ç†èµ„æº
    window.addEventListener('beforeunload', () => {
        viewer.destroy();
    });
});
```

### WebSocketå®æ—¶æ¨é€å®ç°

```java
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {
    
    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(new ProcessInstanceWebSocketHandler(), "/websocket/process-instance")
                .setAllowedOrigins("*");
    }
}

@Component
public class ProcessInstanceWebSocketHandler extends TextWebSocketHandler {
    
    private final Map<String, Set<WebSocketSession>> processInstanceSessions = new ConcurrentHashMap<>();
    
    @Override
    public void afterConnectionEstablished(WebSocketSession session) throws Exception {
        String processInstanceId = getProcessInstanceId(session);
        processInstanceSessions.computeIfAbsent(processInstanceId, k -> ConcurrentHashMap.newKeySet())
                .add(session);
    }
    
    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
        String processInstanceId = getProcessInstanceId(session);
        Set<WebSocketSession> sessions = processInstanceSessions.get(processInstanceId);
        if (sessions != null) {
            sessions.remove(session);
            if (sessions.isEmpty()) {
                processInstanceSessions.remove(processInstanceId);
            }
        }
    }
    
    public void notifyProcessInstanceUpdate(String processInstanceId, ProcessInstanceStatus status) {
        Set<WebSocketSession> sessions = processInstanceSessions.get(processInstanceId);
        if (sessions != null) {
            String message = JSON.toJSONString(status);
            sessions.forEach(session -> {
                try {
                    session.sendMessage(new TextMessage(message));
                } catch (IOException e) {
                    log.error("å‘é€WebSocketæ¶ˆæ¯å¤±è´¥", e);
                }
            });
        }
    }
    
    private String getProcessInstanceId(WebSocketSession session) {
        return Objects.requireNonNull(session.getUri())
                .getQuery()
                .split("processInstanceId=")[1];
    }
}
```

### æµç¨‹äº‹ä»¶ç›‘å¬

```java
@Component
public class ProcessEventListener implements FlowableEventListener {
    
    @Autowired
    private ProcessInstanceWebSocketHandler webSocketHandler;
    
    @Autowired
    private WorkflowController workflowController;
    
    @Override
    public void onEvent(FlowableEvent event) {
        if (event.getType() == FlowableEngineEventType.TASK_CREATED ||
            event.getType() == FlowableEngineEventType.TASK_COMPLETED ||
            event.getType() == FlowableEngineEventType.ACTIVITY_STARTED ||
            event.getType() == FlowableEngineEventType.ACTIVITY_COMPLETED) {
            
            String processInstanceId = event.getProcessInstanceId();
            
            // è·å–æœ€æ–°çŠ¶æ€
            ResponseEntity<ProcessInstanceStatus> response = 
                workflowController.getProcessInstanceStatus(processInstanceId);
            
            if (response.getStatusCode().is2xxSuccessful()) {
                // é€šè¿‡WebSocketæ¨é€æ›´æ–°
                webSocketHandler.notifyProcessInstanceUpdate(processInstanceId, response.getBody());
            }
        }
    }
    
    @Override
    public boolean isFailOnException() {
        return false;
    }
}

@Configuration
public class FlowableConfig {
    
    @Bean
    public ProcessEventListener processEventListener() {
        return new ProcessEventListener();
    }
    
    @Bean
    public ProcessEngineConfigurationConfigurer processEngineConfigurationConfigurer(
            ProcessEventListener eventListener) {
        return configuration -> {
            configuration.setEventListeners(Arrays.asList(eventListener));
        };
    }
}
```

---

## ğŸ¨ å¢å¼ºæ ·å¼å’Œç”¨æˆ·ä½“éªŒ

```css
/* ä¼˜åŒ–çš„CSSæ ·å¼ */
.process-viewer-container {
    display: flex;
    height: 100vh;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.diagram-container {
    flex: 1;
    position: relative;
    border: 1px solid #e8e8e8;
    background-color: #fafafa;
}

.info-panel {
    width: 350px;
    background-color: #fff;
    border-left: 1px solid #e8e8e8;
    overflow-y: auto;
}

/* BPMN.js èŠ‚ç‚¹çŠ¶æ€æ ·å¼ */
.highlight-active .djs-visual > rect,
.highlight-active .djs-visual > circle {
    fill: #52c41a !important;
    stroke: #389e0d !important;
    stroke-width: 3px !important;
    animation: pulse 2s infinite;
}

.highlight-completed .djs-visual > rect,
.highlight-completed .djs-visual > circle {
    fill: #1890ff !important;
    stroke: #096dd9 !important;
    stroke-width: 2px !important;
}

.highlight-pending .djs-visual > rect,
.highlight-pending .djs-visual > circle {
    fill: #f0f0f0 !important;
    stroke: #d9d9d9 !important;
    stroke-width: 1px !important;
}

@keyframes pulse {
    0% { stroke-width: 3px; }
    50% { stroke-width: 5px; }
    100% { stroke-width: 3px; }
}

.info-section {
    padding: 16px;
    border-bottom: 1px solid #f0f0f0;
}

.info-section h3 {
    margin: 0 0 12px 0;
    color: #262626;
    font-size: 16px;
    font-weight: 600;
}

.task-item, .history-item {
    padding: 12px;
    margin-bottom: 8px;
    background-color: #fafafa;
    border-radius: 6px;
    border-left: 3px solid #1890ff;
}

.task-item.active {
    border-left-color: #52c41a;
    background-color: #f6ffed;
}

.status-badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: 500;
}

.status-active {
    background-color: #f6ffed;
    color: #52c41a;
    border: 1px solid #b7eb8f;
}

.status-completed {
    background-color: #e6f7ff;
    color: #1890ff;
    border: 1px solid #91d5ff;
}
```

---

## ğŸš€ éƒ¨ç½²å’Œé›†æˆ

### 1. åç«¯é…ç½®

```yaml
# application.yml
flowable:
  database-schema-update: true
  history-level: full
  check-process-definitions: false
  
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/flowable
    username: root
    password: password
    driver-class-name: com.mysql.cj.jdbc.Driver
    
  websocket:
    allowed-origins: "*"

server:
  port: 8080
```

### 2. å‰ç«¯é›†æˆç¤ºä¾‹

```javascript
// åœ¨ç°æœ‰å®¡æ‰¹é¡µé¢ä¸­é›†æˆ
function initWorkflowViewer(processInstanceId) {
    // åˆ›å»ºå®¹å™¨
    const container = document.createElement('div');
    container.id = 'workflow-viewer-modal';
    container.innerHTML = `
        <div class="modal-overlay">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>æµç¨‹è¿›åº¦</h3>
                    <button class="close-btn" onclick="closeWorkflowViewer()">Ã—</button>
                </div>
                <div class="modal-body">
                    <div id="workflow-canvas" style="height: 500px;"></div>
                </div>
            </div>
        </div>
    `;
    
    document.body.appendChild(container);
    
    // åˆå§‹åŒ–æµç¨‹æŸ¥çœ‹å™¨
    const viewer = new ProcessViewer('workflow-canvas', processInstanceId);
    
    return viewer;
}

function closeWorkflowViewer() {
    const modal = document.getElementById('workflow-viewer-modal');
    if (modal) {
        modal.remove();
    }
}

// åœ¨å®¡æ‰¹åˆ—è¡¨ä¸­æ·»åŠ "æŸ¥çœ‹æµç¨‹"æŒ‰é’®
function addViewProcessButtons() {
    document.querySelectorAll('.approval-item').forEach(item => {
        const processInstanceId = item.dataset.processInstanceId;
        const button = document.createElement('button');
        button.textContent = 'æŸ¥çœ‹æµç¨‹';
        button.onclick = () => initWorkflowViewer(processInstanceId);
        item.appendChild(button);
    });
}
```

---

## ğŸ¯ æ€»ç»“

è¿™ä¸ªæ–¹æ¡ˆæä¾›äº†å®Œæ•´çš„Flowableå·¥ä½œæµå¯è§†åŒ–è§£å†³æ–¹æ¡ˆï¼š

### ä¸»è¦ç‰¹æ€§
1. **å®æ—¶çŠ¶æ€æ›´æ–°** - WebSocketæ¨é€ï¼Œæ— éœ€æ‰‹åŠ¨åˆ·æ–°
2. **ä¸“ä¸šæµç¨‹å›¾** - åŸºäºBPMN.jsçš„æ ‡å‡†æµç¨‹å›¾æ¸²æŸ“
3. **ä¸°å¯Œçš„äº¤äº’** - èŠ‚ç‚¹é«˜äº®ã€çŠ¶æ€åŒºåˆ†ã€è¯¦ç»†ä¿¡æ¯å±•ç¤º
4. **å®Œæ•´çš„API** - æµç¨‹çŠ¶æ€æŸ¥è¯¢ã€å†å²è®°å½•ã€ä»»åŠ¡ä¿¡æ¯
5. **äº‹ä»¶é©±åŠ¨** - åŸºäºFlowableäº‹ä»¶ç›‘å¬å™¨çš„è‡ªåŠ¨æ›´æ–°

### å®æ–½æ­¥éª¤
1. **åç«¯å¼€å‘** - å®ç°APIæ¥å£å’ŒWebSocketæœåŠ¡
2. **å‰ç«¯é›†æˆ** - åœ¨ç°æœ‰é¡µé¢ä¸­åµŒå…¥æµç¨‹æŸ¥çœ‹å™¨
3. **æ ·å¼å®šåˆ¶** - æ ¹æ®UIé£æ ¼è°ƒæ•´è§†è§‰æ•ˆæœ
4. **æµ‹è¯•éªŒè¯** - ç¡®ä¿å„ç§æµç¨‹åœºæ™¯æ­£å¸¸å·¥ä½œ

### æŠ€æœ¯ä¼˜åŠ¿
- åŸºäºæˆç†Ÿçš„å¼€æºæŠ€æœ¯æ ˆ
- æ ‡å‡†çš„BPMN 2.0æ”¯æŒ
- é«˜æ€§èƒ½çš„å®æ—¶æ›´æ–°æœºåˆ¶
- è‰¯å¥½çš„å¯æ‰©å±•æ€§å’Œç»´æŠ¤æ€§

è¿™ä¸ªæ–¹æ¡ˆèƒ½å¤Ÿå®Œç¾æ»¡è¶³ç”²æ–¹çš„éœ€æ±‚ï¼Œè®©ç”¨æˆ·å®æ—¶çœ‹åˆ°å®¡æ‰¹æµç¨‹çš„å½“å‰ä½ç½®å’Œå†å²è¿›åº¦ï¼ 